# -*- coding: utf-8 -*-
"""Cópia de Olá, este é o Colaboratory

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vNjon9P1cj4-KLLy6T-Ai5TYBTnOposq
"""

//1
package main

import "fmt"

func main(){
    var quantidade int
    fmt.Scan(&quantidade)

    var N[100000] int

    for i:=0; i<quantidade;i++{
        fmt.Scan(&N[i])
    }

    var buscas int
    fmt.Scan(&buscas)

    var M[1000] int

    for i:=0; i<buscas;i++{
        fmt.Scan(&M[i])
    }


    for i := 0; i < buscas; i++ {
        encontrado := false
        for j := 0; j < quantidade; j++ {
            if M[i] == N[j] {
                encontrado = true
                break
            }
        }
        if encontrado {
            fmt.Println("ACHEI")
        } else {
            fmt.Println("NAO ACHEI")
        }
    }
}

//2
package main

import "fmt"

func main(){
    var quantidade,k int

    fmt.Scan(&quantidade)

    for quantidade<1 || quantidade>1000{
        fmt.Scan(&quantidade)
    }

    var dados[1000] int

    for i:=0; i<quantidade;i++{

        fmt.Scan(&dados[i])
    }

    fmt.Scan(&k)

    numero:=0

    for i:=0;i<quantidade;i++{
        if dados[i]>=k {
            numero=numero+1
        }
    }

fmt.Print(numero)
}

//3
package main

import "fmt"

func main(){
    var quantidade int
    fmt.Scan(&quantidade)

    var n [5000] int

    for i:=0; i<quantidade; i++{
        fmt.Scan(&n[i])
    }

    for i:=quantidade-1;i>=0;i--{
        fmt.Print(n[i]," ")
    }
}

//4
package main

import"fmt"

func main(){
    var quantidade int
    fmt.Scan(&quantidade)

    var dados[5000] int

    for i:=0; i<quantidade; i++{
        fmt.Scan(&dados[i])
    }

    for i:=0; i<quantidade;i++{
        fmt.Print(dados[i]," ")
    }
}

//5
package main

import"fmt"
var n int
func main(){
    for{
    fmt.Scan(&n)

    if n==0{
        break
    }


    var dados[10000] int
    maiorele:=0
    maiorind:=0


    for i:=0; i<n;i++{
        fmt.Scan(&dados[i])

        if dados[i]>maiorele{
            maiorele=(dados[i])
            maiorind=i
        }

    }

    fmt.Print(maiorind,maiorele)
    }
}

//6
package main

import"fmt"

func main(){
    var quantidade int
    fmt.Scan(&quantidade)

    var dados[5000] int

    for i:=0; i<quantidade; i++{
        fmt.Scan(&dados[i])
    }

    soma:=0
    for i:=0; i<quantidade; i++{
        soma+=dados[i]
    }
      fmt.Print(soma)
}

//7
//deu errado
package main

import "fmt"

func main() {
    for {
        var quantidade int
        fmt.Print("quantidade:")
        fmt.Scan(&quantidade)

        if quantidade == 0 {
            break
        }

        var dados [10000]int
        var maior int

        for i := 0; i < quantidade; i++ {
            fmt.Scan(&dados[i])
            if dados[i] > maior {
                maior = dados[i]
            }
        }


        var frequencia [10001]int

        for i := 0; i < quantidade; i++ {
            frequencia[dados[i]]++
        }

        for i := 0; i <= maior; i++ {
            if frequencia[i] > 0 {
                fmt.Printf("(%d) %d\n", i, frequencia[i])
            }
        }
    }
}

//8
//revisar
package main

import (
	"fmt"
)

func main() {
	var decimal, binario int
	for {
		_, erro := fmt.Scan(&decimal)
		if erro != nil {
			break
		}

		binario = 0
		potencia := 1
		for decimal > 0 {
			digitoBinario := decimal % 2
			binario += digitoBinario * potencia
			decimal /= 2
			potencia *= 10
		}

		fmt.Println(binario)
	}
}

//9
//revisar
package main

import (
    "fmt"
    "math"
)

// Ponto representa um ponto no espaço tridimensional.
type Ponto struct {
    x, y, z float64
}

// distancia calcula a distância entre dois pontos usando a fórmula fornecida no enunciado.
func distancia(p1, p2 Ponto) float64 {
    // Calcula as diferenças nas coordenadas x, y e z entre os dois pontos.
    dx := p1.x - p2.x
    dy := p1.y - p2.y
    dz := p1.z - p2.z

    // Aplica a fórmula de distância euclidiana fornecida no enunciado.
    dist := math.Sqrt(dx*dx + dy*dy + dz*dz)

    return dist
}

func main() {
    var N int
    fmt.Scanln(&N) // Lê o número de pontos do usuário

    var pontos []Ponto

    // Lê as coordenadas dos pontos fornecidos pelo usuário
    for i := 0; i < N; i++ {
        var x, y, z float64
        fmt.Scanln(&x, &y, &z)
        pontos = append(pontos, Ponto{x, y, z})
    }

    // Calcula e imprime as distâncias entre os pontos consecutivos
    for i := 1; i < N; i++ {
        dist := distancia(pontos[i-1], pontos[i])
        fmt.Printf("%.2f\n", dist)
    }
}

//10
package main

import "fmt"

func main() {
    var quantidade int
    fmt.Scan(&quantidade)

    var n [10000]int
    var maiorele, pmaiorele, ultimoele, frequenciaultele int

    for i := 0; i < quantidade; i++ {
        fmt.Scan(&n[i])

        if n[i] > maiorele {
            maiorele = n[i]
            pmaiorele = i
        }

        if i == quantidade-1 {
            ultimoele = n[i]
        }
    }

    for i := 0; i < quantidade; i++ {
        if n[i] == ultimoele {
            frequenciaultele++
        }
    }

    fmt.Println("nota", maiorele, ",", pmaiorele)
    fmt.Println("nota", ultimoele, ",", frequenciaultele)
}

//11
package main

import "fmt"

func main() {
    // Declaração de variáveis
    var N int
    fmt.Println("Digite o tamanho do vetor:")
    fmt.Scanln(&N)

    // Declarando os vetores V e W
    V := make([]int, N)
    W := make([]int, N)

    // Preenchendo o vetor V
    fmt.Println("Digite os valores do vetor V separados por espaço:")
    for i := 0; i < N; i++ {
        fmt.Scan(&V[i])
    }

    // Construindo o vetor W invertido
    for i := 0; i < N; i++ {
        W[N-1-i] = V[i]
    }

    // Encontrando o maior elemento de V
    maxV := V[0]
    for i := 1; i < N; i++ {
        if V[i] > maxV {
            maxV = V[i]
        }
    }

    // Encontrando o menor elemento de W
    minW := W[0]
    for i := 1; i < N; i++ {
        if W[i] < minW {
            minW = W[i]
        }
    }

    // Mostrando o vetor V
    fmt.Println( V)

    // Mostrando o vetor W
    fmt.Println( W)

    // Mostrando o maior elemento de V
    fmt.Println(maxV)

    // Mostrando o menor elemento de W
    fmt.Println(minW)
}

//12
package main

import "fmt"

func main() {
	var quantidade int
	fmt.Scan(&quantidade)

	var array [1000]int

	for i := 0; i < quantidade; i++ {
		fmt.Scan(&array[i])
	}

	// Ordenação dos elementos usando o Bubble Sort
	bubbleSort(array, quantidade)

	// Imprime os elementos ordenados
	for i := 0; i < quantidade; i++ {
		fmt.Print(array[i], " ")
	}
}

// Implementação do algoritmo de ordenação Bubble Sort
func bubbleSort(array [1000]int, n int) {
	for i := 0; i < n-1; i++ {
		for j := 0; j < n-i-1; j++ {
			if array[j] > array[j+1] {
				array[j], array[j+1] = array[j+1], array[j]
			}
		}
	}
}

//13
package main

import "fmt"

func main() {
	var N int
	fmt.Scanln(&N)

	var numeros [101] int

	for i := 0; i < N; i++ {
		var num int
		fmt.Scan(&num)
		numeros[num]++
	}

	var maxFreq, numMaxFreq int
	for num, freq := range numeros {
		if freq > maxFreq || (freq == maxFreq && num < numMaxFreq) {
			maxFreq = freq
			numMaxFreq = num
		}
	}

	fmt.Println(numMaxFreq)
	fmt.Println(maxFreq)
}

//14
//revisar
package main

import (
    "fmt"
)

func main() {
    var N int
    fmt.Scanln(&N)

    var dados [1000000]int // Definindo um array de tamanho máximo

    // Leitura de entrada e armazenamento dos dados no array
    for i := 0; i < N; i++ {
        var num int
        fmt.Scanln(&num)
        dados[i] = num
    }

    // Ordena os dados
    bubbleSort(dados, N)

    var mediana float64
    if N%2 == 0 {
        // Se a quantidade de elementos é par, calcula a média dos dois elementos centrais
        mediana = float64(dados[N/2-1]+dados[N/2]) / 2.0
    } else {
        // Se a quantidade de elementos é ímpar, a mediana é o elemento central
        mediana = float64(dados[N/2])
    }

    // Imprime a mediana com duas casas decimais
    fmt.Printf("%.2f\n", mediana)
}

// Implementação do algoritmo de ordenação bubble sort
func bubbleSort ( array [1000000]int, n int) {
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if array[j] > array[j+1] {
                array[j], array[j+1] = array[j+1], array[j]
            }
        }
    }
}

//15
package main

import (
	"fmt"
	"math"
)

func main() {
	var T int
	fmt.Scanln(&T) // Lendo o número de testes

	for i := 0; i < T; i++ {
		var N int
		fmt.Scanln(&N) // Lendo o tamanho do vetor para o teste atual

		var vetor [1000]int // Criando um array com tamanho máximo de 1000, como especificado
		for j := 0; j < N; j++ {
			fmt.Scan(&vetor[j]) // Lendo os elementos do vetor
		}

		// Chamando a função para calcular a distância mínima e o número de comparações
		distancia, comparacoes := distanciaMinima(vetor, N)
		fmt.Printf("%d %d\n", distancia, comparacoes) // Imprimindo os resultados
	}
}

func distanciaMinima(vetor [1000]int, N int) (int, int) {
	minDistancia := math.MaxInt32 // Inicializando a distância mínima como o máximo inteiro possível
	comparacoes := 0

	// Loop para comparar todos os pares de elementos no vetor
	for i := 0; i < N-1; i++ {
		for j := i + 1; j < N; j++ {
			// Calculando a distância entre os elementos e atualizando a distância mínima, se necessário
			distancia := int(math.Abs(float64(vetor[i] - vetor[j])))
			comparacoes++
			if distancia < minDistancia {
				minDistancia = distancia
			}
		}
	}

	return minDistancia, comparacoes // Retornando a distância mínima e o número de comparações
}

//16
//revisar
package main

import "fmt"

func main() {
	var N, K int
	fmt.Scanln(&N, &K) // Lê N e K do console

	var chegadas []int
	for i := 0; i < N; i++ {
		var chegada int
		fmt.Scan(&chegada) // Lê o tempo de chegada de cada aluno
		chegadas = append(chegadas, chegada)
	}

	// Chama a função para verificar se a aula será cancelada
	cancelada, alunosPresentes := aulaCancelada(N, K, chegadas)
	if cancelada {
		fmt.Println("SIM") // Imprime SIM se a aula for cancelada
	} else {
		fmt.Println("NAO") // Imprime NAO se a aula não for cancelada
		for i := len(alunosPresentes) - 1; i >= 0; i-- {
			fmt.Printf("%d ", alunosPresentes[i]) // Imprime os tempos de chegada dos alunos presentes
		}
		fmt.Println()
	}
}

// Função para verificar se a aula será cancelada
func aulaCancelada(N, K int, chegadas []int) (bool, []int) {
	// Ordenação manual dos tempos de chegada dos alunos usando Bubble Sort
	for i := 0; i < N-1; i++ {
		for j := 0; j < N-i-1; j++ {
			if chegadas[j] > chegadas[j+1] {
				chegadas[j], chegadas[j+1] = chegadas[j+1], chegadas[j]
			}
		}
	}

	alunosPresentes := []int{}
	for _, chegada := range chegadas {
		if chegada <= 0 {
			alunosPresentes = append(alunosPresentes, chegada) // Adiciona os alunos que chegaram a tempo ou antes do tempo de aula
		}
	}

	if len(alunosPresentes) < K {
		return true, nil // Retorna true se o número de alunos presentes for menor que K
	}

	return false, alunosPresentes // Retorna false e os tempos de chegada dos alunos presentes
}

//17
package main

import "fmt"

func main() {
	var n, uniqueCount int
	fmt.Scanln(&n)

	numeros := [5001]int{}

	for i := 0; i < n; i++ {
		var num int
		fmt.Scan(&num)
		numeros[num]++
		if numeros[num] == 1 {
			uniqueCount++
		} else if numeros[num] == 2 {
			uniqueCount--
		}
	}

	fmt.Println(uniqueCount)
}

//18
package main

import (
	"fmt"
)

func validarCPF(cpf [11]int) bool {
	// Verificar primeiro dígito verificador
	soma := 0
	for i := 0; i < 9; i++ {
		soma += cpf[i] * (i + 1)
	}
	digito1 := soma % 11
	if digito1 == 10 {
		digito1 = 0
	}

	// Verificar segundo dígito verificador
	soma = 0
	for i := 0; i < 9; i++ {
		soma += cpf[i] * (9 - i)
	}
	soma += digito1 * 2
	digito2 := soma % 11
	if digito2 == 10 {
		digito2 = 0
	}

	// Verificar se os dígitos verificadores estão corretos
	return digito1 == cpf[9] && digito2 == cpf[10]
}

func main() {
	var T int
	fmt.Scanln(&T)

	for t := 0; t < T; t++ {
		var cpf [11]int
		for i := 0; i < 11; i++ {
			fmt.Scan(&cpf[i])
		}
		if validarCPF(cpf) {
			fmt.Println("CPF valido")
		} else {
			fmt.Println("CPF invalido")
		}
	}
}

//19
package main

import (
    "fmt"
    "sort"
)

func main(){
    var quantidade int
    fmt.Scan(&quantidade)

    var dados[1000] int

    for i := 0; i < quantidade; i++ {
        fmt.Scan(&dados[i])
    }

    // Ordenar apenas os elementos preenchidos até a quantidade inserida
    sort.Ints(dados[:quantidade])

    // Imprimir os elementos ordenados
    for i := 0; i < quantidade; i++ {
        fmt.Print(dados[i], " ")
    }
}

//20
package main

import (
	"fmt"
	"math"
)

// Definindo a estrutura de um ponto no espaço tridimensional
type Ponto struct {
	x, y, z float64
}

// Função para calcular o módulo do vetor entre dois pontos
func magnitudeVetor(p1, p2 Ponto) float64 {
	// Calculando as diferenças em cada coordenada
	dx := p2.x - p1.x
	dy := p2.y - p1.y
	dz := p2.z - p1.z

	// Calculando o valor absoluto máximo entre as diferenças em x, y e z
	return math.Max(math.Max(math.Abs(dx), math.Abs(dy)), math.Abs(dz))
}

func main() {
	var N int
	fmt.Scanln(&N) // Lendo o número de pontos

	var pontos [1000]Ponto // Definindo um array de pontos

	// Lendo as coordenadas dos pontos
	for i := 0; i < N; i++ {
		fmt.Scanln(&pontos[i].x, &pontos[i].y, &pontos[i].z)
	}

	// Calculando e imprimindo o módulo do vetor para cada par de pontos
	for i := 0; i < N-1; i++ {
		magnitude := magnitudeVetor(pontos[i], pontos[i+1])
		fmt.Printf("%.2f\n", magnitude)
	}
	fmt.Println()
}

//21
package main

import "fmt"

func main() {
	var n int
	fmt.Scan(&n)

	var nums [100000]int

	// Lendo os números
	for i := 0; i < n; i++ {
		fmt.Scan(&nums[i])
	}

	// Ordenando os números de acordo com o critério
	for i := 0; i < n; i++ {
		for j := i + 1; j < n; j++ {
			// Se o número atual for par e o próximo for ímpar, troca-os de posição
			if nums[i]%2 == 0 && nums[j]%2 != 0 {
				nums[i], nums[j] = nums[j], nums[i]
			}
			// Se ambos forem pares ou ambos ímpares, ordena em ordem crescente
			if (nums[i]%2 == 0 && nums[j]%2 == 0 && nums[i] > nums[j]) || (nums[i]%2 != 0 && nums[j]%2 != 0 && nums[i] < nums[j]) {
				nums[i], nums[j] = nums[j], nums[i]
			}
		}
	}

	// Imprimindo os números ordenados
	for i := 0; i < n; i++ {
		fmt.Println(nums[i])
	}
}

//24
//revisar
package main

import "fmt"

func main() {
    for {
        var n int
        fmt.Scan(&n) // Lê o tamanho do vetor

        if n == 0 {
            break // Se o tamanho for 0, sai do loop
        }

        var max int // Variável para armazenar o maior elemento
        var dados [10001]int // vetor com tamanho 10001, considerando valores entre 0 e 10000
        for i := 0; i < n; i++ {
            var x int
            fmt.Scan(&x)
            dados[x]++ // Incrementa a contagem do elemento x
            if x > max {
                max = x // Atualiza o maior elemento
            }
        }

        // Imprimir os valores ordenados
        for i := 0; i <= max; i++ {
            for j := 0; j < dados[i]; j++ {
                fmt.Print(i) // Imprime o elemento i
                if j < dados[i]-1 {
                    fmt.Print(" ") // Adiciona espaço entre os elementos, exceto o último elemento de cada chave
                }
            }
        }
        fmt.Println() // Quebra de linha após imprimir todos os elementos ordenados
    }
}

//26
package main

import "fmt"

func main() {
	var n int
	fmt.Scan(&n)

	for t := 0; t < n; t++ {
		var casos [9]int
		for i := 0; i < 9; i++ {
			fmt.Scan(&casos[i])
		}

		for a := 0; a < 9; a++ {
			for b := a + 1; b < 9; b++ {
				soma := 0
				for i := 0; i < 9; i++ {
					if i != a && i != b {
						soma += casos[i]
					}
				}
				if soma == 100 {
					// Bubble Sort para ordenar os anões
					for i := 0; i < 7; i++ {
						for j := 0; j < 6-i; j++ {
							if casos[j] > casos[j+1] {
								casos[j], casos[j+1] = casos[j+1], casos[j]
							}
						}
					}
					// Imprimir os anões ordenados
					for i := 0; i < 7; i++ {
						fmt.Println(casos[i])
					}
					// Terminar o loop após encontrar a solução
					return
				}
			}
		}
	}
}